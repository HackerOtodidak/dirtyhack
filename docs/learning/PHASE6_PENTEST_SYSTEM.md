# Phase 6: Building an AI PenTest Multi-Agent System

This tutorial guides you through designing and implementing an autonomous multi-agent penetration testing and bug bounty hunting system using the patterns learned from SecureVibes.

---

## Table of Contents

1. [System Overview](#1-system-overview)
2. [Architecture Design](#2-architecture-design)
3. [Agent Definitions](#3-agent-definitions)
4. [Prompt Engineering for PenTest](#4-prompt-engineering-for-pentest)
5. [Orchestration Strategy](#5-orchestration-strategy)
6. [Artifact Schema Design](#6-artifact-schema-design)
7. [Security Hooks for PenTest](#7-security-hooks-for-pentest)
8. [Skills for Exploitation](#8-skills-for-exploitation)
9. [Complete Implementation](#9-complete-implementation)
10. [Testing and Safety](#10-testing-and-safety)

---

## 1. System Overview

### Goal

Build an autonomous multi-agent system that:
1. Discovers attack surface (domains, services, endpoints)
2. Identifies vulnerabilities
3. Validates findings with proof-of-concept
4. Generates professional reports

### Comparison with SecureVibes

| SecureVibes (SAST) | PenTest System (DAST/External) |
|-------------------|--------------------------------|
| Analyzes source code | Analyzes running systems |
| File-based input | Network-based input |
| Static analysis | Dynamic testing |
| Code vulnerabilities | Runtime vulnerabilities |
| Internal perspective | Attacker perspective |

### Agent Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ORCHESTRATOR                             â”‚
â”‚     "Coordinate penetration test phases sequentially"           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                         â”‚                         â”‚
     â–¼                         â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RECON   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  SCANNER â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ EXPLOIT  â”‚
â”‚  AGENT   â”‚ scope.json â”‚  AGENT   â”‚ vulns.json â”‚  AGENT   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                                â”‚
     â”‚                                                â–¼
     â”‚                                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ REPORTER â”‚
     â”‚                                         â”‚  AGENT   â”‚
     â”‚                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                                â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         REPORT.md
```

---

## 2. Architecture Design

### Directory Structure

```
pentest-agent/
â”œâ”€â”€ pentest/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ definitions.py      # Agent definitions
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ main.py             # CLI entry point
â”‚   â”œâ”€â”€ config.py               # Configuration
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ finding.py          # Finding data model
â”‚   â”‚   â””â”€â”€ result.py           # Scan result model
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”‚   â”œâ”€â”€ recon.txt
â”‚   â”‚   â”‚   â”œâ”€â”€ scanner.txt
â”‚   â”‚   â”‚   â”œâ”€â”€ exploit.txt
â”‚   â”‚   â”‚   â””â”€â”€ reporter.txt
â”‚   â”‚   â””â”€â”€ orchestration/
â”‚   â”‚       â””â”€â”€ main.txt
â”‚   â”œâ”€â”€ scanner/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ scanner.py          # Main scanner class
â”‚   â”‚   â””â”€â”€ hooks.py            # Safety hooks
â”‚   â”œâ”€â”€ skills/
â”‚   â”‚   â””â”€â”€ exploitation/
â”‚   â”‚       â”œâ”€â”€ sqli-testing/
â”‚   â”‚       â”œâ”€â”€ xss-testing/
â”‚   â”‚       â””â”€â”€ auth-bypass/
â”‚   â””â”€â”€ reporters/
â”‚       â”œâ”€â”€ markdown.py
â”‚       â””â”€â”€ json.py
â”œâ”€â”€ tests/
â”œâ”€â”€ .pentest/                   # Output directory
â””â”€â”€ pyproject.toml
```

### Artifact Flow

```
.pentest/
â”œâ”€â”€ SCOPE.json              # Recon output: targets, services
â”œâ”€â”€ ATTACK_SURFACE.json     # Scanner input enrichment
â”œâ”€â”€ VULNERABILITIES.json    # Scanner output: findings
â”œâ”€â”€ EXPLOITS.json           # Exploit agent: PoCs
â”œâ”€â”€ scan_results.json       # Final compiled results
â””â”€â”€ REPORT.md               # Human-readable report
```

---

## 3. Agent Definitions

### Agent Registry

```python
# pentest/agents/definitions.py

from claude_agent_sdk import AgentDefinition
from pentest.prompts.loader import load_prompt
from pentest.config import config

def create_agents(cli_model=None, target=None):
    """Create penetration testing agent definitions."""
    
    return {
        "recon": AgentDefinition(
            description="Discovers attack surface: subdomains, ports, services, technologies",
            prompt=load_prompt("recon").replace("{target}", target or ""),
            tools=["Bash", "Write"],
            model=config.get_model("recon", cli_model)
        ),
        
        "scanner": AgentDefinition(
            description="Identifies vulnerabilities in discovered services",
            prompt=load_prompt("scanner"),
            tools=["Read", "Bash", "Write"],
            model=config.get_model("scanner", cli_model)
        ),
        
        "exploit": AgentDefinition(
            description="Validates vulnerabilities with proof-of-concept exploits",
            prompt=load_prompt("exploit"),
            tools=["Read", "Bash", "Write", "Skill"],
            model=config.get_model("exploit", cli_model)
        ),
        
        "reporter": AgentDefinition(
            description="Generates professional penetration test report",
            prompt=load_prompt("reporter"),
            tools=["Read", "Write"],
            model=config.get_model("reporter", cli_model)
        )
    }
```

### Tool Selection Rationale

| Agent | Tools | Why |
|-------|-------|-----|
| Recon | Bash, Write | Run discovery tools (nmap, subfinder) |
| Scanner | Read, Bash, Write | Read scope, run scanners, write findings |
| Exploit | Read, Bash, Write, Skill | Read vulns, run exploits, use skill docs |
| Reporter | Read, Write | Read all artifacts, write report |

---

## 4. Prompt Engineering for PenTest

### Recon Agent Prompt

```text
# pentest/prompts/agents/recon.txt

You are a reconnaissance expert for penetration testing.

<target>
Primary Target: {target}
</target>

<scope_rules>
CRITICAL: Only test what is explicitly in scope.
- Do NOT scan third-party services
- Do NOT perform destructive actions
- Log all commands for audit trail
</scope_rules>

<methodology>
1. PASSIVE RECON
   - DNS enumeration
   - WHOIS lookup
   - Certificate transparency logs
   
2. SUBDOMAIN DISCOVERY
   ```bash
   # Example (adapt based on tools available)
   subfinder -d {target} -o subdomains.txt 2>/dev/null || echo "subfinder not available"
   ```

3. PORT SCANNING
   ```bash
   # Quick top ports scan
   nmap -sT -T4 --top-ports 100 {target} -oN nmap_quick.txt
   ```

4. SERVICE FINGERPRINTING
   - Identify web servers, APIs, databases
   - Note versions for vulnerability matching

5. TECHNOLOGY DETECTION
   - Frameworks (React, Django, etc.)
   - CMS systems (WordPress, etc.)
   - Known vulnerable components
</methodology>

<output_format>
Write results to .pentest/SCOPE.json:
{
  "target": "{target}",
  "timestamp": "ISO-8601",
  "subdomains": [
    {"hostname": "...", "ip": "...", "status": "up|down"}
  ],
  "services": [
    {
      "host": "...",
      "port": 443,
      "protocol": "tcp",
      "service": "https",
      "version": "nginx/1.18",
      "banner": "..."
    }
  ],
  "technologies": [
    {"name": "...", "version": "...", "confidence": "high|medium|low"}
  ],
  "notes": ["..."]
}
</output_format>

REMEMBER: Stay within scope. Document everything.
```

### Scanner Agent Prompt

```text
# pentest/prompts/agents/scanner.txt

You are a vulnerability scanner specializing in web application security.

<input>
Read .pentest/SCOPE.json for target information.
</input>

<methodology>
For each service in scope:

1. WEB APPLICATION TESTING
   - Directory/file enumeration
   - Parameter discovery
   - Authentication testing
   
2. VULNERABILITY CATEGORIES
   Check for:
   - SQL Injection (SQLi)
   - Cross-Site Scripting (XSS)
   - Server-Side Request Forgery (SSRF)
   - Insecure Direct Object References (IDOR)
   - Authentication bypass
   - Information disclosure
   - Security misconfigurations
   
3. TESTING APPROACH
   ```bash
   # Directory enumeration
   gobuster dir -u https://target.com -w /usr/share/wordlists/common.txt -o dirs.txt
   
   # Parameter fuzzing (example)
   curl -s "https://target.com/api/user?id=1" | head -20
   ```

4. EVIDENCE COLLECTION
   - Capture requests/responses
   - Note exact reproduction steps
   - Assess severity accurately
</methodology>

<severity_guidelines>
CRITICAL: RCE, auth bypass to admin, data breach potential
HIGH: SQLi, stored XSS, privilege escalation
MEDIUM: Reflected XSS, CSRF, information disclosure
LOW: Missing headers, verbose errors, minor misconfigs
INFO: Observations without security impact
</severity_guidelines>

<output_format>
Write to .pentest/VULNERABILITIES.json:
[
  {
    "id": "VULN-001",
    "title": "SQL Injection in login endpoint",
    "severity": "critical",
    "cwe": "CWE-89",
    "cvss": 9.8,
    "endpoint": "POST /api/login",
    "parameter": "username",
    "description": "...",
    "evidence": {
      "request": "...",
      "response": "...",
      "payload": "...'OR'1'='1"
    },
    "reproduction_steps": ["..."],
    "impact": "...",
    "recommendation": "..."
  }
]
</output_format>

Only report CONFIRMED vulnerabilities with evidence.
```

### Exploit Agent Prompt

```text
# pentest/prompts/agents/exploit.txt

You are an ethical exploitation specialist.

<purpose>
Validate vulnerabilities from .pentest/VULNERABILITIES.json by creating
proof-of-concept exploits that demonstrate impact WITHOUT causing damage.
</purpose>

<ethical_guidelines>
CRITICAL RULES:
1. DO NOT exfiltrate real user data
2. DO NOT modify production data
3. DO NOT cause denial of service
4. DO NOT pivot to out-of-scope systems
5. STOP if you encounter sensitive PII

Acceptable PoC actions:
âœ… Read your own test user's data
âœ… Demonstrate access control bypass
âœ… Show error messages revealing info
âœ… Extract non-sensitive metadata
</ethical_guidelines>

<methodology>
For each vulnerability:

1. READ the vulnerability details
2. UNDERSTAND the attack vector
3. CRAFT minimal PoC that proves exploitability
4. DOCUMENT exact steps
5. RATE exploitability and impact

Example SQLi PoC:
```bash
# Confirm boolean-based SQLi
curl -s "https://target.com/api/user?id=1" > baseline.txt
curl -s "https://target.com/api/user?id=1 AND 1=1" > test1.txt
curl -s "https://target.com/api/user?id=1 AND 1=2" > test2.txt

# Compare responses
diff baseline.txt test1.txt  # Should be same
diff baseline.txt test2.txt  # Should differ = SQLi confirmed
```
</methodology>

<validation_status>
- VALIDATED: PoC works, impact demonstrated
- PARTIAL: Vulnerability exists but limited exploitability
- FALSE_POSITIVE: Cannot reproduce, may be false positive
- BLOCKED: WAF/controls prevent exploitation
</validation_status>

<output_format>
Write to .pentest/EXPLOITS.json:
[
  {
    "vulnerability_id": "VULN-001",
    "validation_status": "VALIDATED",
    "exploitability": "easy|medium|hard",
    "poc": {
      "type": "bash_script|curl_command|python_script",
      "code": "...",
      "expected_result": "...",
      "actual_result": "..."
    },
    "impact_demonstrated": "...",
    "notes": "..."
  }
]
</output_format>
```

### Reporter Agent Prompt

```text
# pentest/prompts/agents/reporter.txt

You are a professional penetration test report writer.

<input>
Read all artifacts:
- .pentest/SCOPE.json
- .pentest/VULNERABILITIES.json
- .pentest/EXPLOITS.json
</input>

<report_structure>
Create .pentest/REPORT.md with:

# Penetration Test Report

## Executive Summary
- High-level findings
- Risk assessment
- Key recommendations

## Scope and Methodology
- Target systems
- Testing timeframe
- Tools and techniques used

## Findings Summary
| Severity | Count |
|----------|-------|
| Critical | X     |
| High     | X     |
| Medium   | X     |
| Low      | X     |

## Detailed Findings

### [SEVERITY] Finding Title
**ID:** VULN-XXX
**CVSS:** X.X
**CWE:** CWE-XXX

**Description:**
[Clear explanation]

**Affected Endpoint:**
[URL/location]

**Evidence:**
[PoC details]

**Impact:**
[Business impact]

**Recommendation:**
[Specific fix]

---

[Repeat for each finding]

## Recommendations Summary
- Priority 1 (Immediate): ...
- Priority 2 (Short-term): ...
- Priority 3 (Medium-term): ...

## Appendix
- Tools used
- Testing methodology
- Disclaimer
</report_structure>

Write professional, clear, actionable content.
```

---

## 5. Orchestration Strategy

### Main Orchestration Prompt

```text
# pentest/prompts/orchestration/main.txt

Perform a penetration test on the target system.

<environment_checks>
- Check PENTEST_TARGET environment variable for target
- Check PENTEST_SCOPE for scope limitations
- Check SKIP_PHASES for phases to skip
</environment_checks>

Execute these phases SEQUENTIALLY:

PHASE 1: RECONNAISSANCE
- Announce: "Starting Phase 1: Reconnaissance"
- Use 'recon' agent to discover attack surface
- Creates .pentest/SCOPE.json
- Report findings count when complete
- WAIT before proceeding

PHASE 2: VULNERABILITY SCANNING
- Announce: "Starting Phase 2: Vulnerability Scanning"
- Use 'scanner' agent to identify vulnerabilities
- Reads SCOPE.json
- Creates .pentest/VULNERABILITIES.json
- Report vulnerability count by severity
- WAIT before proceeding

PHASE 3: EXPLOITATION VALIDATION
- Announce: "Starting Phase 3: Exploitation Validation"
- Use 'exploit' agent to validate findings
- Reads VULNERABILITIES.json
- Creates .pentest/EXPLOITS.json
- Report validation statistics
- WAIT before proceeding

PHASE 4: REPORT GENERATION
- Announce: "Starting Phase 4: Report Generation"
- Use 'reporter' agent to create final report
- Reads all artifacts
- Creates .pentest/REPORT.md and scan_results.json
- Report completion

CRITICAL RULES:
- Execute ONE phase at a time
- Announce each phase transition
- Respect scope limitations
- Stop if target becomes unresponsive
```

---

## 6. Artifact Schema Design

### SCOPE.json

```json
{
  "target": "example.com",
  "timestamp": "2024-01-15T10:30:00Z",
  "scope": {
    "in_scope": ["*.example.com", "api.example.com"],
    "out_of_scope": ["mail.example.com", "third-party.com"]
  },
  "subdomains": [
    {
      "hostname": "www.example.com",
      "ip": "192.168.1.1",
      "status": "up",
      "http_status": 200
    }
  ],
  "services": [
    {
      "host": "www.example.com",
      "port": 443,
      "protocol": "tcp",
      "service": "https",
      "version": "nginx/1.18.0",
      "state": "open"
    }
  ],
  "technologies": [
    {
      "name": "React",
      "version": "17.0.2",
      "category": "javascript-framework"
    }
  ],
  "endpoints": [
    {
      "url": "https://api.example.com/v1/users",
      "method": "GET",
      "parameters": ["id", "limit"]
    }
  ]
}
```

### VULNERABILITIES.json

```json
[
  {
    "id": "VULN-001",
    "title": "SQL Injection in User Lookup",
    "severity": "critical",
    "cwe": "CWE-89",
    "cvss_score": 9.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
    "endpoint": {
      "url": "https://api.example.com/v1/users",
      "method": "GET",
      "parameter": "id"
    },
    "description": "The 'id' parameter is vulnerable to SQL injection...",
    "evidence": {
      "request": "GET /v1/users?id=1' OR '1'='1 HTTP/1.1\nHost: api.example.com",
      "response": "HTTP/1.1 200 OK\n...\n[{\"id\":1,...},{\"id\":2,...}]",
      "payload": "1' OR '1'='1"
    },
    "reproduction_steps": [
      "Navigate to /v1/users endpoint",
      "Add SQL injection payload to 'id' parameter",
      "Observe all users returned instead of single user"
    ],
    "impact": "An attacker can extract all database contents...",
    "recommendation": "Use parameterized queries..."
  }
]
```

### EXPLOITS.json

```json
[
  {
    "vulnerability_id": "VULN-001",
    "validation_status": "VALIDATED",
    "exploitability": "easy",
    "poc": {
      "type": "curl_command",
      "code": "curl -s 'https://api.example.com/v1/users?id=1%27%20OR%20%271%27=%271'",
      "expected_result": "Returns all users instead of user with id=1",
      "actual_result": "Returned 150 user records"
    },
    "impact_demonstrated": "Extracted 150 user records including emails",
    "time_to_exploit": "< 1 minute",
    "skill_required": "low",
    "notes": "No WAF or rate limiting detected"
  }
]
```

---

## 7. Security Hooks for PenTest

### Scope Enforcement Hook

```python
# pentest/scanner/hooks.py

def create_scope_hook(allowed_targets: list, console, debug):
    """Prevent testing out-of-scope targets."""
    
    async def scope_hook(input_data: dict, tool_use_id: str, ctx: dict) -> dict:
        tool_name = input_data.get("tool_name")
        
        if tool_name != "Bash":
            return {}
        
        command = input_data.get("tool_input", {}).get("command", "")
        
        # Extract potential targets from command
        for target in extract_targets(command):
            if not is_in_scope(target, allowed_targets):
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": f"Target {target} is out of scope"
                    }
                }
        
        return {}
    
    return scope_hook

def extract_targets(command: str) -> list:
    """Extract hostnames/IPs from command."""
    import re
    
    # Match URLs
    urls = re.findall(r'https?://([^/\s]+)', command)
    
    # Match IP addresses
    ips = re.findall(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', command)
    
    # Match hostnames in common tool patterns
    # nmap target, curl URL, etc.
    
    return urls + ips

def is_in_scope(target: str, allowed: list) -> bool:
    """Check if target matches allowed patterns."""
    import fnmatch
    
    for pattern in allowed:
        if fnmatch.fnmatch(target, pattern):
            return True
    return False
```

### Destructive Action Prevention

```python
def create_safety_hook(console, debug):
    """Prevent destructive actions."""
    
    BLOCKED_PATTERNS = [
        "rm -rf",
        "DROP TABLE",
        "DELETE FROM",
        "UPDATE .* SET",
        "INSERT INTO",
        "; rm",
        "| rm",
        "mkfs",
        "dd if=",
        "shutdown",
        "reboot",
    ]
    
    async def safety_hook(input_data: dict, tool_use_id: str, ctx: dict) -> dict:
        tool_name = input_data.get("tool_name")
        
        if tool_name != "Bash":
            return {}
        
        command = input_data.get("tool_input", {}).get("command", "")
        
        for pattern in BLOCKED_PATTERNS:
            if re.search(pattern, command, re.IGNORECASE):
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": f"Destructive action blocked: {pattern}"
                    }
                }
        
        return {}
    
    return safety_hook
```

### Rate Limiting Hook

```python
import time
from collections import defaultdict

def create_rate_limit_hook(requests_per_minute: int = 60):
    """Rate limit requests to prevent DoS."""
    
    request_times = defaultdict(list)
    
    async def rate_limit_hook(input_data: dict, tool_use_id: str, ctx: dict) -> dict:
        tool_name = input_data.get("tool_name")
        
        if tool_name != "Bash":
            return {}
        
        command = input_data.get("tool_input", {}).get("command", "")
        
        # Check if it's a network request
        if not any(tool in command for tool in ["curl", "wget", "nmap", "nikto"]):
            return {}
        
        # Extract target
        targets = extract_targets(command)
        
        for target in targets:
            now = time.time()
            minute_ago = now - 60
            
            # Clean old entries
            request_times[target] = [t for t in request_times[target] if t > minute_ago]
            
            if len(request_times[target]) >= requests_per_minute:
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": f"Rate limit exceeded for {target}"
                    }
                }
            
            request_times[target].append(now)
        
        return {}
    
    return rate_limit_hook
```

---

## 8. Skills for Exploitation

### SQL Injection Testing Skill

```markdown
# .claude/skills/exploitation/sqli-testing/SKILL.md

---
name: sqli-testing
description: SQL injection detection and exploitation techniques. Use for CWE-89 vulnerabilities.
---

# SQL Injection Testing Skill

## Detection Techniques

### Error-Based Detection
```bash
# Trigger SQL error
curl -s "https://target.com/api?id=1'" | grep -i "sql\|syntax\|mysql\|postgres"
```

### Boolean-Based Detection
```bash
# Compare true vs false conditions
curl -s "https://target.com/api?id=1 AND 1=1" > true.txt
curl -s "https://target.com/api?id=1 AND 1=2" > false.txt
diff true.txt false.txt
```

### Time-Based Detection
```bash
# Measure response time
time curl -s "https://target.com/api?id=1; WAITFOR DELAY '0:0:5'--"
```

## Exploitation (Ethical PoC Only)

### Extract Database Version
```bash
curl -s "https://target.com/api?id=1' UNION SELECT version()--"
```

### Extract Table Names (INFORMATION_SCHEMA)
```bash
curl -s "https://target.com/api?id=1' UNION SELECT table_name FROM information_schema.tables--"
```

## Validation Criteria
- VALIDATED: Can extract data beyond intended query
- PARTIAL: Error messages but no data extraction
- FALSE_POSITIVE: Input sanitized, no injection
```

### XSS Testing Skill

```markdown
# .claude/skills/exploitation/xss-testing/SKILL.md

---
name: xss-testing
description: Cross-site scripting detection techniques. Use for CWE-79 vulnerabilities.
---

# XSS Testing Skill

## Detection Approach

### Reflected XSS
```bash
# Test reflection
PAYLOAD="<script>alert('XSS')</script>"
curl -s "https://target.com/search?q=${PAYLOAD}" | grep -i "<script>alert"
```

### Filter Bypass Payloads
```bash
# If <script> blocked
curl -s "https://target.com/search?q=<img src=x onerror=alert(1)>"

# If quotes blocked
curl -s "https://target.com/search?q=<img src=x onerror=alert(String.fromCharCode(88,83,83))>"
```

## Validation
- VALIDATED: Payload executes (confirmed in response)
- PARTIAL: Payload reflected but may be browser-dependent
- FALSE_POSITIVE: Input properly escaped
```

---

## 9. Complete Implementation

### Main Scanner Class

```python
# pentest/scanner/scanner.py

import os
import asyncio
from pathlib import Path
from typing import Optional

from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions
from claude_agent_sdk.types import AssistantMessage, TextBlock, ResultMessage, HookMatcher

from pentest.agents.definitions import create_agents
from pentest.prompts.loader import load_prompt
from pentest.scanner.hooks import create_scope_hook, create_safety_hook, create_rate_limit_hook
from pentest.models.result import PentestResult


class PentestScanner:
    """Autonomous penetration testing scanner."""
    
    def __init__(
        self,
        target: str,
        scope: list = None,
        model: str = "sonnet",
        debug: bool = False,
        rate_limit: int = 60
    ):
        self.target = target
        self.scope = scope or [f"*.{target}", target]
        self.model = model
        self.debug = debug
        self.rate_limit = rate_limit
        self.total_cost = 0.0
    
    async def scan(self, output_dir: str = ".pentest") -> PentestResult:
        """Run complete penetration test."""
        
        # Setup output directory
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        # Set environment variables for orchestration
        os.environ["PENTEST_TARGET"] = self.target
        
        # Create agents
        agents = create_agents(cli_model=self.model, target=self.target)
        
        # Create safety hooks
        scope_hook = create_scope_hook(self.scope, None, self.debug)
        safety_hook = create_safety_hook(None, self.debug)
        rate_hook = create_rate_limit_hook(self.rate_limit)
        
        # Configure SDK
        options = ClaudeAgentOptions(
            agents=agents,
            cwd=str(Path.cwd()),
            setting_sources=["project"],
            allowed_tools=["Skill", "Read", "Write", "Bash"],
            max_turns=100,
            permission_mode='bypassPermissions',
            model=self.model,
            hooks={
                "PreToolUse": [
                    HookMatcher(hooks=[scope_hook]),
                    HookMatcher(hooks=[safety_hook]),
                    HookMatcher(hooks=[rate_hook])
                ]
            }
        )
        
        # Load orchestration prompt
        orchestration = load_prompt("main", category="orchestration")
        
        # Execute scan
        print(f"ğŸ¯ Starting penetration test against: {self.target}")
        print(f"ğŸ“‹ Scope: {self.scope}")
        print("=" * 60)
        
        async with ClaudeSDKClient(options=options) as client:
            await client.query(orchestration)
            
            async for message in client.receive_messages():
                if isinstance(message, AssistantMessage):
                    for block in message.content:
                        if isinstance(block, TextBlock):
                            text = block.text.strip()
                            if text:
                                print(f"ğŸ“ {text[:200]}")
                
                elif isinstance(message, ResultMessage):
                    if message.total_cost_usd:
                        self.total_cost = message.total_cost_usd
                    break
        
        print("=" * 60)
        print(f"âœ… Scan complete! Cost: ${self.total_cost:.4f}")
        
        # Load results
        return self._load_results(output_path)
    
    def _load_results(self, output_path: Path) -> PentestResult:
        """Load scan results from artifacts."""
        import json
        
        vulns_file = output_path / "VULNERABILITIES.json"
        exploits_file = output_path / "EXPLOITS.json"
        
        vulnerabilities = []
        if vulns_file.exists():
            vulnerabilities = json.loads(vulns_file.read_text())
        
        exploits = []
        if exploits_file.exists():
            exploits = json.loads(exploits_file.read_text())
        
        return PentestResult(
            target=self.target,
            vulnerabilities=vulnerabilities,
            exploits=exploits,
            total_cost=self.total_cost
        )
```

### CLI Entry Point

```python
# pentest/cli/main.py

import asyncio
import click
from rich.console import Console

from pentest.scanner.scanner import PentestScanner

console = Console()

@click.group()
def cli():
    """ğŸ”“ AI-Powered Penetration Testing"""
    pass

@cli.command()
@click.argument('target')
@click.option('--scope', '-s', multiple=True, help='Additional in-scope patterns')
@click.option('--model', '-m', default='sonnet', help='Claude model to use')
@click.option('--output', '-o', default='.pentest', help='Output directory')
@click.option('--debug', is_flag=True, help='Enable debug output')
@click.option('--rate-limit', default=60, help='Requests per minute limit')
def scan(target, scope, model, output, debug, rate_limit):
    """Run penetration test against TARGET."""
    
    # Confirm before testing
    console.print(f"[bold yellow]âš ï¸  About to test: {target}[/bold yellow]")
    console.print("\nEnsure you have authorization to test this target!")
    
    if not click.confirm("Proceed?", default=False):
        console.print("[yellow]Cancelled[/yellow]")
        return
    
    # Prepare scope
    scope_list = list(scope) if scope else []
    scope_list.append(f"*.{target}")
    scope_list.append(target)
    
    # Run scan
    scanner = PentestScanner(
        target=target,
        scope=scope_list,
        model=model,
        debug=debug,
        rate_limit=rate_limit
    )
    
    result = asyncio.run(scanner.scan(output))
    
    # Display summary
    console.print("\n[bold]ğŸ“Š Results Summary[/bold]")
    console.print(f"Vulnerabilities: {len(result.vulnerabilities)}")
    console.print(f"Validated: {len([e for e in result.exploits if e.get('validation_status') == 'VALIDATED'])}")
    console.print(f"Report: {output}/REPORT.md")

if __name__ == '__main__':
    cli()
```

---

## 10. Testing and Safety

### Safety Checklist

Before using on any target:

- [ ] **Written authorization** from target owner
- [ ] **Defined scope** - exactly what to test
- [ ] **Time window** agreed upon
- [ ] **Emergency contact** in case of issues
- [ ] **Rate limits** configured appropriately
- [ ] **Data handling** plan (don't store PII)

### Testing Locally

```bash
# Set up a vulnerable test application
docker run -d -p 3000:3000 vulnerables/web-dvwa

# Run pentest against local target
python -m pentest scan localhost:3000 --scope "localhost*"
```

### Unit Tests

```python
# tests/test_hooks.py

import pytest
from pentest.scanner.hooks import is_in_scope, extract_targets

def test_scope_matching():
    allowed = ["*.example.com", "api.example.com"]
    
    assert is_in_scope("www.example.com", allowed) == True
    assert is_in_scope("api.example.com", allowed) == True
    assert is_in_scope("evil.com", allowed) == False

def test_target_extraction():
    command = "curl https://api.example.com/users && nmap 192.168.1.1"
    targets = extract_targets(command)
    
    assert "api.example.com" in targets
    assert "192.168.1.1" in targets

def test_blocked_commands():
    from pentest.scanner.hooks import create_safety_hook
    
    hook = create_safety_hook(None, False)
    
    # Should block
    result = asyncio.run(hook(
        {"tool_name": "Bash", "tool_input": {"command": "rm -rf /"}},
        "test-id", {}
    ))
    assert "deny" in str(result)
    
    # Should allow
    result = asyncio.run(hook(
        {"tool_name": "Bash", "tool_input": {"command": "curl https://example.com"}},
        "test-id", {}
    ))
    assert result == {}
```

---

## Summary

You've learned how to design and implement a penetration testing multi-agent system:

| Component | Pattern | Purpose |
|-----------|---------|---------|
| Agents | Specialized experts | Recon, Scan, Exploit, Report |
| Orchestration | Sequential phases | Coordinate agent execution |
| Artifacts | JSON files | Inter-agent communication |
| Hooks | Safety gates | Scope, destructive action, rate limiting |
| Skills | Methodology docs | Exploitation techniques |
| Config | Environment vars | Customization |

### Key Takeaways

1. **Design agents with single responsibility** - Each agent does one thing well
2. **Use file-based communication** - Debuggable, resumable, auditable
3. **Implement safety hooks** - Prevent out-of-scope and destructive actions
4. **Define clear artifact schemas** - Downstream agents know what to expect
5. **Create skills for complex techniques** - Claude follows documented methodologies
6. **Test thoroughly before production** - Local vulnerable apps first

---

## Exercises

1. **Add a new agent**: Create a "social engineering" agent that generates phishing templates (for authorized testing only!)

2. **Create a new skill**: Write a skill for testing JWT vulnerabilities

3. **Implement resume capability**: Allow continuing a scan from a specific phase

4. **Add DefectDojo integration**: Report findings to your DefectDojo instance

5. **Build a dashboard**: Create a web UI showing scan progress and results

---

## Congratulations!

You've completed the SecureVibes knowledge transfer. You now understand:

- Python fundamentals for agent development
- Claude Agent SDK core concepts
- Multi-agent architecture patterns
- Advanced features (hooks, skills, cost tracking)
- Complete SecureVibes implementation
- How to build your own multi-agent systems

**Go build amazing things!** ğŸš€

